#!/usr/bin/env python3

import os
import platform
import subprocess
import sys
from os.path import exists

os.environ["FZF_DEFAULT_OPTS"] = (
    os.environ.get("FZF_DEFAULT_OPTS", "") + " --layout=reverse"
)


class bcolors:
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


def _run(cmd, stdin=None):
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stdin=subprocess.PIPE, shell=True)
    if isinstance(stdin, str):
        stdin = stdin.encode("utf8")
    stdout, stderr = p.communicate(input=stdin)
    return (
        stdout.decode("utf-8").strip() if stdout else "",
        stderr.decode("utf-8").strip() if stderr else "",
    )


def _is_macos():
    return platform.system() == "Darwin"


def select_from_container(only_running=False, return_origin=False):
    format = "--format 'table {{.ID}}\t{{.State}}\t{{.Names}}\t{{.Image}}'"
    cmd = "docker ps " + (" " if only_running else "-a ") + format
    containers, _ = _run(cmd)
    containers = containers.splitlines()[1:]

    if exists("./docker-compose.yml") or exists("./docker-compose.yaml"):
        cmd = "docker-compose ps" + ("" if only_running else " -a")
        compose, _ = _run(cmd)
        compose_container_names = set(
            [line.split()[0] for line in compose.splitlines()[1:]]
        )

        def _get_container_key(line):
            name = line.split()[2]
            return 1 if name in compose_container_names else 2

        containers.sort(key=_get_container_key)

    stdout, _ = _run(
        f"fzf -e --prompt='Container> '",
        stdin="\n".join(containers),
    )
    if return_origin:
        return stdout
    return "" if not stdout else stdout.split()[2]


def ssh_list_hosts(ori):
    with open(os.path.expanduser("~/.ssh/config")) as f:
        hosts = []
        for line in f:
            if not line.startswith("Host "):
                continue
            if line.startswith("Host *"):
                continue
            hosts += [host.strip() for host in line.split()[1:]]
    stdout, _ = _run(f"fzf -e --prompt='Host> '", stdin="\n".join(hosts))
    return f"{ori} {stdout} " if stdout else ori


def kill_with_pids(ori):
    stdout, _ = _run("ps -ef | fzf -e --prompt='Process> '")
    pids = [line.split()[1] for line in stdout.splitlines()]
    return f"{ori} {' '.join(pids)} " if pids else ori


def top_with_pids(ori):
    stdout, _ = _run("ps -ef | fzf -e --prompt='Process> '")
    pids = [line.split()[1] for line in stdout.splitlines()]
    if len(pids) > 20:
        pids = pids[:20]
    if _is_macos():
        return f"top {' '.join(['-pid ' + pid for pid in pids])} " if pids else ori
    return f"{ori} -p {','.join(pids)} " if pids else ori


def docker_container_log(ori):
    name = select_from_container(only_running=False)
    return f"d logs -f {name} --tail=10" if name else ori


def docker_container_exec_shell(ori):
    name = select_from_container(only_running=True)
    if not name:
        return ori
    os_info, _ = _run(f"docker exec {name} cat /etc/os-release")
    os_info = os_info.splitlines()[0]
    sh = "sh" if "alpine" in os_info.lower() else "bash"
    return f"d exec -it {name} {sh} "


def docker_inspect(ori):
    cmds = [
        "docker images --format 'table img {{.ID}}\t{{.Repository}}\t{{.Tag}}'",
        "docker volume ls --format 'table vol {{.Name}}'",
        "docker network ls --format 'table net {{.ID}}\t{{.Name}}\t{{.Driver}}\t{{.Scope}}'",
        "docker ps -a --format 'table ps  {{.ID}}\t{{.State}}\t{{.Names}}\t{{.Image}}'",
    ]
    r = [_run(cmd)[0].split("\n", 1) for cmd in cmds]
    r = [x[1] if len(x) > 1 else "" for x in r]
    stdout, _ = _run(f"fzf -e --prompt='Inspect> '", stdin="\n".join(r))
    items = []
    for line in stdout.strip().splitlines():
        if line.startswith("ps"):
            items.append(line.split()[3])
        elif line.startswith("img"):
            _, _, repo, tag = line.split()
            items.append(f"{repo}:{tag}")
        elif line.startswith("net"):
            items.append(line.split()[2])
        elif line.startswith("vol"):
            items.append(line.split()[1])
    return f"d inspect {' '.join(items)} " if items else ori


def docker_image_remove(ori):
    stdout, _ = _run(
        "docker images --format 'table {{.ID}}\t{{.Repository}}\t{{.Tag}}\t{{.Size}}'"
    )
    stdout, _ = _run(
        f"fzf -e --prompt='Image> '",
        stdin=stdout.split("\n", 1)[1],
    )
    items = []
    for line in stdout.strip().splitlines():
        id, repo, tag, size = line.split()
        label = f"{repo}:{tag}"
        items.append(label if label != "<none>:<none>" else id)
    return f"d rmi {' '.join(items)} " if items else ori


def docker_container_run(ori):
    stdout, _ = _run(
        "docker images --format 'table {{.ID}}\t{{.Repository}}\t{{.Tag}}\t{{.Size}}'"
    )
    stdout, _ = _run(
        f"fzf -e --prompt='Image> '",
        stdin=stdout.split("\n", 1)[1],
    )
    out = stdout.split()
    return f"d run --rm -it {out[1]}:{out[2]} sh " if out else ori


def docker_container_remove(ori):
    stdout = select_from_container(only_running=False, return_origin=True)
    if not stdout:
        return ori

    stop, rm = [], []
    for line in stdout.strip().splitlines():
        if line.startswith("CONTAINER ID"):
            continue
        _, state, name, _ = line.split()
        rm.append(name)
        if state != "exited":
            stop.append(name)
    cmd = ""
    if len(stop) > 0:
        cmd += f"d stop {' '.join(stop)} && "
    cmd += f"d rm {' '.join(rm)} "
    return cmd


def git_checkout(ori):
    branch, _ = _run("git branch -a --format='%(refname:short)'")
    lines = ["br: " + line.strip() for line in branch.splitlines()]
    tag, _ = _run("git tag")
    lines += ["tag: " + line.strip() for line in tag.splitlines()]
    stdout, _ = _run(f"fzf -e --prompt='Ref> '", stdin="\n".join(lines))
    ref = stdout.split()[1]
    return f"{ori} {ref} " if ref else ori


def show_process_of_port(ori):
    stdout, _ = _run("sudo netstat -tunlp | fzf -e")
    print(f"\n{bcolors.HEADER}{bcolors.BOLD}[{stdout}]{bcolors.ENDC}", file=sys.stderr)
    pid = stdout.split()[-1].split("/")[0]
    return f"ps -Tf -p {pid}" if pid else ori


def to_directory(ori):
    if ori.replace("cd", "").strip() == "" or ori.startswith("z"):
        query = ori.replace("z", "").strip() if ori.startswith("z") else ""
        stdout, _ = _run(
            f"zoxide query -l {query} | fzf -e --prompt='Zoxide Workspace> '"
        )
    else:
        prefix = ori.replace("cd", "").strip()
        stdout, _ = _run(
            f"fd --type directory '' {prefix} | fzf -e --prompt='Directory> '"
        )
    return f"cd {stdout} " if stdout else ori


def git_show_ref(ori):
    preview_opt = "--preview-window=right,30%"
    preview = '''--preview="echo {}|cut -d' ' -f1|xargs git diff-tree --no-commit-id --name-only -r"'''
    stdout, _ = _run(
        f"git log --color=always| fzf -e {preview} {preview_opt} --prompt='Ref> '"
    )
    return f"g show {stdout.split()[0]} " if stdout else ori


def git_diff_with_name(ori):
    stdout, _ = _run(f"git diff --name-only| fzf -e --prompt='File> '")
    return f"g diff {stdout} " if stdout else ori


def supervisorctl_tail(ori):
    stdout, _ = _run(f"sudo supervisorctl status| fzf -e --prompt='Process> '")
    return f"sv tail -f {stdout.split()[0]} " if stdout else ori


def golang_unit_test_by_function(ori):
    stdout, _ = _run(
        f"rg --no-follow --color=always --no-line-number --no-heading -g '*_test.go' -r '$1' 'func (Test.*)\\(.*' . | fzf -e --prompt='Test Fuc> '"
    )
    file, case = stdout.splitlines()[0].split(":")
    exe = "gotest" if ori.startswith("got") else "go test"
    return f"{exe} {os.path.dirname(file)} -v -run {case}$ "


def python_test_by_function(ori):
    stdout, _ = _run(
        f"rg --no-follow --color=always --no-line-number --no-heading -g 'test_*.py' -r '$1' '.*def (test_.*)\\(.*' . | fzf -e --prompt='Test Fuc> '"
    )
    _, case = stdout.splitlines()[0].split(":")
    exe = "brownie test" if ori.startswith("bt") else "pytest"
    return f"{exe} -s -k {case}$ "


prefix = {
    "ssh": ssh_list_hosts,
    "kill": kill_with_pids,
    "top": top_with_pids,
    "d run": docker_container_run,
    "d l": docker_container_log,
    "d e": docker_container_exec_shell,
    "d sh": docker_container_exec_shell,
    "d i": docker_inspect,
    "d rmi": docker_image_remove,
    "d rm": docker_container_remove,
    "net": show_process_of_port,
    "cd": to_directory,
    "z": to_directory,
    "g ck": git_checkout,
    "g checkout": git_checkout,
    "g s": git_show_ref,
    "g d": git_diff_with_name,
    "sv t": supervisorctl_tail,
    "got": golang_unit_test_by_function,
    "go t": golang_unit_test_by_function,
    "pyt": python_test_by_function,
    "bt": python_test_by_function,
}

alias = {
    "d": "docker",
    "g": "git",
    "dc": "docker-compose",
    "sv": "sudo supervisorctl",
}

if len(sys.argv) < 2:
    print(bcolors.HEADER + "Prefix\t\tDescription" + bcolors.ENDC)
    for item in prefix:
        key = (item + ":").ljust(15)
        print(f"{key} {prefix[item].__name__}")
else:
    ori = sys.argv[1].strip()
    for k, v in alias.items():
        if ori.startswith(v + " "):
            ori = ori.replace(v + " ", k + " ", 1)
            break
    result = ""
    for item in prefix:
        if ori.startswith(item):
            result = prefix[item](ori)
            break
    print(result if result else ori)
