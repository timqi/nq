#!/usr/bin/env python3
tasks = """
[ssh-to-host]
command=ssh ${host}

[kill-with-pids]
command=kill ${space_pids}

[top-with-pids]
command=top ${top_pids}

[cd-to-zoxide-workspace]
command=cd ${zoxide}

[cd-to-custom-directory]
command=cd ${sub_directory_of_input}

[ps-from-netstat-port]
command=ps -Tf -p ${pid_form_netstat}

[docker-run-image]
command=docker run --rm -it ${docker_image} sh

[docker-container-log]
command=docker logs -f ${docker_container} --tail=10

[docker-container-execute]
command=docker exec -it ${docker_container_with_shell}

[docker-remove-images]
command=docker rmi ${space_docker_images}

[docker-remove-containers]
command=${docker_remove_command}

[docker-inspect-item]
command=docker inspect ${docker_element}

[git-check-ref]
command=git checkout ${git_ref}

[supervisort-logs]
command=sudo supervisorctl tail -f ${sv_proc}

[golang-function-test]
command=go test ${go_test_pkg} -v -run ${go_test_func}$$

[pytest-function-test]
command=pytest -s -k ${pytest_func}
"""

import argparse
import configparser
import os
import platform
import shutil
import string
import subprocess
import sys
from os.path import exists

global_cache_map = {}


def _run(cmd, stdin=None):
    p = subprocess.Popen(
        cmd, stdout=subprocess.PIPE, stdin=subprocess.PIPE, shell=True, env=os.environ
    )
    if isinstance(stdin, str):
        stdin = stdin.encode("utf8")
    stdout, stderr = p.communicate(input=stdin)
    return (
        stdout.decode("utf-8").strip() if stdout else "",
        stderr.decode("utf-8").strip() if stderr else "",
    )


def sudo_wrapper(func):
    def wrap(*args, **kwargs):
        if os.getuid() == 0:
            return func(*args, **kwargs)

        argv = [arg.replace("\n", "\\\n") for arg in sys.argv]
        cmd = "sudo " + " ".join(argv) + " --run-identifier " + func.__name__
        stdout, stderr = _run(cmd)
        if stderr:
            error(stderr)
        return stdout

    return wrap


def _is_macos():
    return platform.system() == "Darwin"


def _add_sudo(cmd):
    return cmd if _is_macos() else "sudo " + cmd


def _idf_pids():
    stdout, _ = _run("ps -ef | fzf -e --prompt='Process> '")
    return [line.split()[1] for line in stdout.splitlines()]


def idf_comma_pids():
    return ",".join(_idf_pids())


def idf_space_pids():
    return " ".join(_idf_pids())


def idf_top_pids():
    pids = _idf_pids()
    if _is_macos():
        return " ".join(["-pid " + pid for pid in pids])
    return "-p " + ",".join(pids)


def idf_docker_container_with_shell():
    containers = _idf_docker_containers(only_running=True)
    if not containers:
        return
    container = containers[0]
    cmd = f"docker exec {container} cat /etc/os-release"
    os_info, _ = _run(_add_sudo(cmd))
    os_info = os_info.splitlines()[0]
    sh = "sh" if "alpine" in os_info.lower() else "bash"
    return container + " " + sh


def idf_docker_element():
    cmds = [
        "docker images --format 'table img {{.ID}}\t{{.Repository}}\t{{.Tag}}'",
        "docker volume ls --format 'table vol {{.Name}}'",
        "docker network ls --format 'table net {{.ID}}\t{{.Name}}\t{{.Driver}}\t{{.Scope}}'",
        "docker ps -a --format 'table ps  {{.ID}}\t{{.State}}\t{{.Names}}\t{{.Image}}'",
    ]
    if not _is_macos():
        cmds = ["sudo " + cmd for cmd in cmds]
    r = [_run(cmd)[0].split("\n", 1) for cmd in cmds]
    r = [x[1] if len(x) > 1 else "" for x in r]
    stdout, _ = _run(f"fzf -e --prompt='Inspect> '", stdin="\n".join(r))
    items = []
    for line in stdout.strip().splitlines():
        if line.startswith("ps"):
            items.append(line.split()[3])
        elif line.startswith("img"):
            _, _, repo, tag = line.split()
            items.append(f"{repo}:{tag}")
        elif line.startswith("net"):
            items.append(line.split()[2])
        elif line.startswith("vol"):
            items.append(line.split()[1])
    return " ".join(items)


def idf_space_docker_images():
    images = _idf_docker_images()
    return " ".join(images)


def _idf_docker_images():
    stdout, _ = _run(
        "docker images --format 'table {{.ID}}\t{{.Repository}}\t{{.Tag}}\t{{.Size}}'"
    )
    if not stdout:
        return None
    stdout, _ = _run(
        f"fzf -e --prompt='Dockr Image> '",
        stdin=stdout.split("\n", 1)[1],
    )
    images = []
    for line in stdout.splitlines():
        id, repo, tag, _ = line.split()
        if repo + tag == "<none><none>":
            images.append(id)
        else:
            images.append(repo + ":" + tag)
    return images


def idf_docker_image():
    images = _idf_docker_images()
    return images[0] if images else ""


def _idf_docker_containers(only_running=False):
    format = "--format 'table {{.ID}}\t{{.State}}\t{{.Names}}\t{{.Image}}'"
    cmd = "docker ps -a " + format
    cmd = _add_sudo(cmd)
    containers, _ = _run(cmd)
    containers = containers.splitlines()[1:]
    if only_running:
        containers = [c for c in containers if c.split()[1] == "running"]
    if exists("./docker-compose.yml") or exists("./docker-compose.yaml"):
        cmd = "docker-compose ps"
        cmd = _add_sudo(cmd)
        compose, _ = _run(cmd)
        compose_container_names = set(
            [line.split()[0] for line in compose.splitlines()[1:]]
        )

        def _get_container_key(line):
            name = line.split()[2]
            return 1 if name in compose_container_names else 2

        containers.sort(key=_get_container_key)
    stdout, _ = _run(
        f"fzf -e --prompt='Docker Container> '",
        stdin="\n".join(containers),
    )
    return [line.split()[2] for line in stdout.splitlines()]


def idf_docker_container():
    containers = _idf_docker_containers()
    return " ".join(containers)


def idf_docker_remove_command():
    selected_containers = _idf_docker_containers()
    if not selected_containers:
        return
    format = "--format 'table {{.Names}}\t{{.State}}'"
    cmd = "docker ps -a " + format
    cmd = _add_sudo(cmd)
    containers, _ = _run(cmd)
    stop, rm = [], []
    for line in containers.splitlines()[1:]:
        if line.startswith("CONTAINER ID"):
            continue
        name, state = line.split()
        if name not in selected_containers:
            continue
        rm.append(name)
        if state != "exited":
            stop.append(name)
    cmd = ""
    if len(stop) > 0:
        cmd += f"d stop {' '.join(stop)} && "
    cmd += f"d rm {' '.join(rm)} "
    return cmd


def idf_git_ref():
    branch, _ = _run("git branch -a --format='%(refname:short)'")
    lines = ["br: " + line.strip() for line in branch.splitlines()]
    tag, _ = _run("git tag")
    lines += ["tag: " + line.strip() for line in tag.splitlines()]
    stdout, _ = _run(f"fzf -e --prompt='Ref> '", stdin="\n".join(lines))
    ref = stdout.split()[1]
    return ref if ref else None


def idf_pid_form_netstat():
    if _is_macos():
        error("netstat not supported in macOS")
    stdout, _ = _run("sudo netstat -tunlp | fzf -e")
    print(f"\nnetstat: {stdout}", file=sys.stderr)
    pid = stdout.split()[-1].split("/")[0]
    return pid if pid else ""


def idf_zoxide():
    stdout, _ = _run(f"zoxide query -l | fzf -e --prompt='Zoxide> '")
    return stdout.splitlines()[0] if stdout else ""


def idf_sub_directory_of_input():
    cmd = os.environ.get("ORIGINAL_COMMAND", "")
    parent = cmd.replace("cd", "").strip()
    folder = os.path.expanduser(parent) if parent else "."
    find_cmd = (
        f"fd --type directory '' {folder}"
        if shutil.which("fd")
        else f"find {folder} -type d"
    )
    stdout, _ = _run(f"{find_cmd} | fzf -e --prompt='Directory> '")
    return stdout.splitlines()[0] if stdout else ""


@sudo_wrapper
def idf_sv_proc():
    stdout, _ = _run(f"sudo supervisorctl status| fzf -e --prompt='Supervisor Procs> '")
    return stdout.split()[0] if stdout else None


def _idf_go_test():
    cache_key = "go-test-file-case"
    if cache_key not in global_cache_map:
        stdout, _ = _run(
            f"rg --no-follow --color=always --no-line-number --no-heading -g '*_test.go' -r '$1' 'func (Test.*)\\(.*' . | fzf -e --prompt='Test Fuc> '"
        )
        file, case = stdout.splitlines()[0].split(":")
        global_cache_map[cache_key] = (file, case)
    return global_cache_map[cache_key]


def idf_go_test_pkg():
    return _idf_go_test()[0]


def idf_go_test_func():
    return _idf_go_test()[1]


def idf_pytest_func():
    stdout, _ = _run(
        f"rg --no-follow --color=always --no-line-number --no-heading -g 'test_*.py' -r '$1' '.*def (test_.*)\\(.*' . | fzf -e --prompt='Test Fuc> '"
    )
    _, case = stdout.splitlines()[0].split(":")
    return case


def error(*args, **kwargs):
    if len(args) == 0 and len(kwargs) == 0:
        sys.exit(0)
    print(*args, file=sys.stderr, **kwargs)
    sys.exit(1)


def parse_alias(alias, command):
    for line in alias.splitlines():
        short, long = line.split("=", 1)
        long = long.strip("'").strip('"').strip()
        if command.startswith(long + " "):
            return command.replace(long + " ", short + " ")
    return command


def idf_host():
    with open(os.path.expanduser("~/.ssh/config")) as f:
        hosts = []
        for line in f:
            if not line.startswith("Host "):
                continue
            if line.startswith("Host *"):
                continue
            hosts += [host.strip() for host in line.split()[1:]]
    stdout, _ = _run(f"fzf -e --prompt='Host> '", stdin="\n".join(hosts))
    return stdout.strip()


def handle_section(section):
    var_map, g = {}, globals()
    command = section["command"]
    for identifier in string.Formatter().parse(command):
        if not identifier[1]:
            continue
        identifier = identifier[1]
        idf_fun_name = "idf_" + identifier
        if idf_fun_name not in g:
            error("Can't get identifier ${%s}" % identifier)
        if not callable(g[idf_fun_name]):
            error(idf_fun_name + " is not callable")
        val = g[idf_fun_name]()
        var_map[identifier] = val if val else ""
    # print(var_map)
    command = string.Template(command).substitute(var_map)
    return command


def select_section(query):
    config = configparser.ConfigParser()
    config.read_string(tasks)
    task_list = []
    for section in config.sections():
        task_list.append(f"{section}: {config[section]['command']}")
    query = f" --query '{query}' " if query else ""
    stdout, _ = _run(f"fzf {query} --prompt='Tasks> '", stdin="\n".join(task_list))
    if not stdout.strip():
        return
    name = stdout.splitlines()[0].split(":", 1)[0]
    return config[name]


def handle_command(command, with_run):
    if not with_run:
        print(command + " ")
        return
    if not input(command + " [yYcr]"):
        stdout, stderr = _run(command)
        if stdout:
            print(stdout)
        if stderr:
            print(stderr, file=sys.stderr)


def main(args):
    if args.list_available_identifier:
        for item in globals().copy():
            if item.startswith("idf_"):
                print(item)
        error()

    os.environ["FZF_DEFAULT_OPTS"] = (
        os.environ.get("FZF_DEFAULT_OPTS", "") + " --layout=reverse"
    )

    if args.section:
        os.environ["ORIGINAL_COMMAND"] = args.section

    if args.run_identifier:
        if args.run_identifier not in globals():
            error(f"No identifier {args.run_identifier} found")
        print(globals()[args.run_identifier]())
        sys.exit(0)

    section = select_section(args.section)
    if not section:
        error()

    command = handle_section(section)
    if not command:
        error()

    command = parse_alias(args.alias, command)
    if not command:
        error()

    handle_command(command, args.with_run)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--alias", default="", type=str)
    parser.add_argument("--section", default="", type=str)
    parser.add_argument("--run-identifier", default="", type=str)
    parser.add_argument("--with-run", action="store_true", default=False)
    parser.add_argument("--list-available-identifier", action="store_true")
    args = parser.parse_args()
    main(args)
